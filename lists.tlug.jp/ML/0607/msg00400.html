<!-- MHonArc v2.6.16 -->
<!--X-Subject: Re: [tlug] issues with format of double (or IEEE754) -->
<!--X-From-R13: Xvz <wrc200404Npbyhzohf.ee.pbz> -->
<!--X-Date: Thu, 27 Jul 2006 03:37:22 +0900 -->
<!--X-Message-Id: 20060726143719.6c14093a.jep200404@example.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 20060726125907.GH5111@example.com&#45;61.karlov.mff.cuni.cz -->
<!--X-Reference: 20060726103316.5fd3a597.jep200404@example.com -->
<!--X-Reference: 20060726160548.GJ5111@example.com&#45;61.karlov.mff.cuni.cz -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
  <title>TLUG Mailing List</title>
  <meta http-equiv="Content-type" content="text/html">
  <meta name="Author" content="Jim Tittsler - listmaster TLUG">
  <meta http-equiv="keywords" content="Tokyo Linux Users Group mailing list archive.">
</head>
 
<body bgcolor="#FFFFFF" text="#000000" BACKGROUND="../back3grnd.gif">
<BLOCKQUOTE>
<CENTER><IMG SRC="../tlug_logo.gif"><BR>Mailing List Archive</CENTER>
<P>
<TABLE BGCOLOR="#FFFF66" BORDER=1 COLS=1 WIDTH="90%" CLASS=navbar>
<TR>
<TD>&nbsp;&nbsp;
<FONT FACE="Verdana, Lucida Sans, Arial, Helvetica, Geneva, sans-serif"><SMALL>
<A HREF="../../index.html" TITLE="Tokyo Linux Users Group Page">
<STRONG>tlug.jp</STRONG></A> 
<IMG SRC="../../images/arrow_yellow.gif" WIDTH=13 HEIGHT=9 ALIGN=bottom ALT="-&gt;">
<A HREF="../../list.html" TITLE="Mailing List Page">Mailing List</A> 
<IMG SRC="../../images/arrow_yellow.gif" WIDTH=13 HEIGHT=9 ALIGN=bottom ALT="-&gt;">
<A HREF="../index.html" TITLE="tlug Archive Page">tlug archive</A> 
<IMG SRC="../../images/arrow_yellow.gif" WIDTH=13 HEIGHT=9 ALIGN=bottom ALT="-&gt;">
tlug Mailing List Archive
</SMALL></FONT>
</TD></TR>
</TABLE>
<P>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00392.html">Date Prev</a>][<a href="msg00393.html">Date Next</a>][<a href="msg00389.html">Thread Prev</a>][<a href="msg00404.html">Thread Next</a>][<a href="maillist.html#00400">Date Index</a>][<a href="threads.html#00400">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: [tlug] issues with format of double (or IEEE754)</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li>Date: Wed, 26 Jul 2006 14:37:19 -0400</li>
<li><strong>From</strong>: <strong>Jim &lt;<a href="mailto:jep200404@DOMAIN.HIDDEN?SUBJECT=Re:%20%5Btlug%5D%20issues%20with%20format%20of%20double%20%28or%20IEEE754%29">jep200404@example.com</a>&gt;</strong></li>
<li><strong>Subject</strong>: <strong>Re: [tlug] issues with format of double (or IEEE754)</strong></li>
<li>References: &lt;<a href="mailto:20060726125907.GH5111@DOMAIN.HIDDEN?SUBJECT=Re:%20%5Btlug%5D%20issues%20with%20format%20of%20double%20%28or%20IEEE754%29">20060726125907.GH5111@example.com</a>&gt;	&lt;<a href="mailto:20060726103316.5fd3a597.jep200404@DOMAIN.HIDDEN?SUBJECT=Re:%20%5Btlug%5D%20issues%20with%20format%20of%20double%20%28or%20IEEE754%29">20060726103316.5fd3a597.jep200404@example.com</a>&gt;	&lt;<a href="mailto:20060726160548.GJ5111@DOMAIN.HIDDEN?SUBJECT=Re:%20%5Btlug%5D%20issues%20with%20format%20of%20double%20%28or%20IEEE754%29">20060726160548.GJ5111@example.com</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>On Wed, 26 Jul 2006 18:05:48 +0200 Michal Hajek &lt;hajek1@example.com&gt; wrote:

&gt; Hello :)
&gt; 
&gt;  
&gt; &gt; &gt; on an i386 mashine...

&gt; Oh, I see the point now... it is not an actual 386 procesor. 

OK. 

&gt; Sorry for the confusion. My mystake.  

OK. Precision is good in technical writing. 

&gt; &gt; &gt; char result_normal_plus[17]=&quot;00000000000000000&quot;;
&gt; &gt; 
&gt; &gt; If that is global, keep in mind that result_normal_plus will 
&gt; &gt; initialized only _once_. 
&gt;  
&gt; yes, thank you for pointing that out. But I consider the inicialization
&gt; as a side issue for the time being :) 

It is, but such wierdness raises my suspicion 
that you don't know what you are doing. 

You might have had a good reason for doing what you did, 
but when I see several wierdnesses, 
I start thinking very broadly about programming errors. 

&gt; as for the number 17, it is just ad-hoc number. 
&gt; I choose it only to be long enough. 

OK. 

By the way, 17 is a very special number. 
Did you know that it is the only random prime number? :-)

&gt; Since later I put &quot;end of string&quot; mark at position 10, ...

... you needed something longer than just 10 bytes. I understood that much. 
I was curious about the remaining 6 bytes. 

&gt; ... I did not bother to use the other 7 bits in any way. 

bits or bytes? (It's a rhetorical question. Don't answer it. Just be careful)

&gt; I thought I can change it to lower number later, when everything works
&gt; well. 

Yup. 

&gt; &gt; I am confused about which data is binary and which data is ASCII. 
&gt; &gt; I get the hazy impression that ibrd() does binary, 
&gt; &gt; so seeing result_normal_plus[ibcnt]='\0' looks odd. 
&gt; 
&gt; The function ibrd is implemented (by people writing gpib code for linux)
&gt; as:
&gt; int ibrd(int ud, void *buffer, long num_bytes); 

I know, I read the link you cited enough to see the function prototype. 
It has a strong binary feel to it, not a string feel to it. 

&gt; The problem is, that first 16bit read from the nanovoltmeter are two
&gt; asci characters (#0 header) which I do not want. Being a poor programer
&gt; myself, I could not find any other solution than just take everything
&gt; and store it in a string. 

The concept of a string in C has a very strong convention of being 
NUL terminated. Because you have binary data (which might have a 0 byte 
which could prematurely terminate data), 
you can not handle the overall data as a NUL terminated string. 
That's part of why ibrd() is passed and returns byte counts. 

result_normal_plus[ibcnt]='\0'; likely causes no problem, 
but is a strong indication that you don't fully understand the 
difference between handling arbitrary binary data and NUL terminated 
strings in C. 

Although the wierdnesses I see do not reveal any definite bugs to me, 
they indicate low understaning of the data and C, so this raises the 
probability that you have a programming bug somewhere. 

As far as accessing the first two bytes as characters, 
here are a couple of valid ways to handle them: 

1. You can deal with individual characters as just individual characters
   (that are not in a string). I.e., you can directly access the first 
   two characters as result_normal_plus[0] and result_normal_plus[1]. 

2. Access them as a NUL-terminated string. The NUL terminator would likely 
   clobber the following binary data payload, so either the two character 
   header or the following binary data would have to be copied elsewhere. 
   I prefer copying the header to a NUL terminated string: 

      #define HEADER_LEN (2)
      char header[HEADER_LEN+1];

      header[0]=result_normal_plus[0];
      header[1]=result_normal_plus[1];
      header[2]='\0';

   or

      #define HEADER_LEN (2)
      char header[HEADER_LEN+1];

      {
         int i;

         for (i=0;i&lt;HEADER_LEN;i++)
             header[i]=result_normal_plus[i];
         header[i]='\0';
      }

&gt; Than 

then 

&gt; point another variable (a pointer to
&gt; double) to the right place in the string (kind of saying &quot;from this
&gt; point on take the following 8 characters as a double floating point
&gt; number&quot;).

I fully understood: 

   double *presult;
   presult=result_normal_plus+2;

It's a valid way to do stuff. The concern is that the exact format 
from the meter is different than the floating point format used by 
your C program. Since reading on Wikipedia that the '387 fully 
supported IEEE 754, this is only a small concern. 

&gt; &gt; Parse it by hand. Calculate what you believe the numbers to be. 
&gt; 
&gt; Out of despair, I have already started to work on that :) 

Good. 

&gt; But the results are not so easy to obtain... :) 

I fully understand. I have done so before standardization when I 
was trying to understand undocumented floating point formats. 

&gt; &gt; (BTW, where does ibcnt come from?)
&gt; 
&gt; ibcnt is set by ibrd() to the number of bytes read. 

OK. I see now that I RTFM more. 

&gt; So I use the information to cut the string in the right place. 

You have ibcnt binary bytes. 
You do _not_ have a nul terminated string. 
Stop thinking in of the mixed ASCII and binary data returned by ibrd() 
in terms of a nul terminated string. 

&gt; Sometimes it could be 0, if something goes wrong with the devices on
&gt; gpib bus or the bus itself. If all works ok, than the ibcnt is same as
&gt; the number you give to ibrd as last parameter. 

Yup. 

Since you are dealing with binary data, 
drop the result_normal_plus[ibcnt]='\0';. 

&gt; &gt; First, make it work right, then make it work correct. 
&gt; ...
&gt; &gt; Did reading in ASCII, then converting with atof() work correctly? 
&gt; 
&gt; yes, it works well. No problem. 

Then use it. 

Even if you had trouble with it, it would be easier to fix 
because it is already in a human readable format. 
Also, the maintainance would be easier, because atof() 
does not rely on IEEE754 being the native format and 
so buys you portability. Portability is a good thing. 

BTW, when you get ASCII data, you probably _should_ deal with 
the ASCII data as nul-terminated strings. 
(Clobbering a comma delimiter with '\0' is probably OK)
In other words, when dealing with binary data, 
result_normal_plus[ibcnt]='\0' is very wierd. 
When dealing with a nul-terminated string, 
result_normal_plus[ibcnt]='\0' is required. 

&gt; &gt; How much time does it take to do it _correctly_? 
&gt; well, I intend to run a measurement in a loop. One such loop has about
&gt; four atof() and whole together takes about 0.8 seconds to finish. 

0.8 seconds? That is a very long time, even for a 16MHz '386. 
atof() is NOT your speed problem. Just make sure the string 
you give to atof() is nul terminated. 

&gt; I do not know how much time I can save with avoindig atof(). 

The speed of atof() is not your problem. 

page 15-5 of the Keithley manual is not clear about 
which end the speed degradation could be from. 
Although speed is mentioned along with BASIC, 
there could be speed issues inside the meter itself. 
Even so, I still think it likely that ASCII format 
is not responsible for your speed problems. 

&gt; From profiler I
&gt; cannot source the information, since atof() is buried inside another
&gt; function. But if I run the program in gdb, than my personal subjective
&gt; impression is, that atof() takes considerably more time than for example
&gt; ibrd(). 

ibrd() is likely a &quot;blocking&quot; call. 
It likely spends most of its time asleep waiting for input. 

&gt; I do not know any other way how to find the information :( 

Since you know how to use a profiler, 
you can put atof() inside an encapsulating function, 
just so that you can measure the time of the encapsulating function. 

I.e., in your program call debug_atof() instead of atof(), where: 

   double debug_atof(const char *nptr)
   {
      return atof(nptr);
   }

then run your profiler on debug_atof(). 

&gt; &gt; Is the ASCII format and atof(), the fastest way that works _correctly_?
&gt; &gt; Avoid premature optimization. 
&gt; 
&gt; Well, the program is rather simple. 

Good. Simplicity is a very practical high virtue. 

&gt; Maybe this is a wrong path from the
&gt; point of view of having work done. But I also want to know how things
&gt; work. So my line of reasoning was based on these assumptions :
&gt; 
&gt; 1. the manual (which I believed) says the nanovoltmeter can return
&gt; values in binary IEEE754 double precision format

OK. 

&gt; 2. it should be possible to exploit this feature and avoid atof(). 

Yes. 

But where does your C compiler _guarantee_ that it likes IEEE 754? 

(Your C compiler probably _does_ grok IEEE 754, 
but where is that guaranteed?)

&gt; When the program does not work like I expected, I tend to look for the
&gt; errors in the program first and try to stick to assumptions as long as
&gt; possible. 

Excellent! 

Considering the wierdnesses I've seen, it is likely that you have bugs. 

&gt; Only [after] I understand why the assumptions are wrong, I am
&gt; satisfied and can leave them aside happily :) 

Me too. 

&gt; &gt; Why do you care about speed? How much speed is enough? 
&gt; 
&gt; This is difficult to say. The nanovoltmeter can make a conversion very
&gt; quickly, but for my purpose about 16.6ms would be ok. 

atof() even on a 16MHz '386 is not your speed problem. 

In one loop, there
&gt; are 4 measurements. Together less than 0.07s.  For my math model, 7 loops
&gt; per second would be great. So there is about 0.5s for all the remaining
&gt; work on the computer side. But for a computer 0.5s could be a lot of
&gt; time, right? :) 

0.5s is a very long time. 

&gt; I do not know if I can reach this value, but every speed up will be
&gt; good. I want to go to the possible limit of hw.  Maybe I will have to go
&gt; realtime, but for the first approximation, I want to try without it. 

Your program can be made to be damn fast. 

&gt; &gt; just worry about correctness and making your program easy to understand. 
&gt; 
&gt; [A]gree[d]. At least easy to understand is definitely my goal too. 

If you don't understand your code, then it is almost guaranteed to have bugs, 
especially considering the wierdnesses that I've seen in what little 
you've shown. 

&gt; Unfortunately, right now the timing of my work is a problem. I have
&gt; about 24 hours to find a solution and than I am leaving for 7 day
&gt; holiday.  

Make it work _right_, then make it work _fast_. 

Always code for clear understanding. 

(Unless you forgot a nul-terminator for the argument), 
atof() is not your speed problem. 

By the way, is there a speed penalty in the _meter_ for outputing 
in ASCII? If you don't try to parse or display them, how fast 
can you read numbers from the meter? If you can read fast, then 
your speed problem is in your full program. If you can not read 
fast, then maybe there is a speed problem in the meter. 


</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00380" href="msg00380.html">[tlug] issues with format of double (or IEEE754)</a></strong>
<ul><li><em>From:</em> Michal Hajek</li></ul></li>
<li><strong><a name="00383" href="msg00383.html">Re: [tlug] issues with format of double (or IEEE754)</a></strong>
<ul><li><em>From:</em> Jim</li></ul></li>
<li><strong><a name="00384" href="msg00384.html">Re: [tlug] issues with format of double (or IEEE754)</a></strong>
<ul><li><em>From:</em> Michal Hajek</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00392.html">Re: [tlug] What does 80387 have to do with IEEE 754 issues? It's moot. (was Re: issues with format of double (or IEEE754))</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00393.html">[tlug] Internal floating point formats used by 80387, IEEE 754 and C . . . . . (was Re: What does 80387 have to do with IEEE 754 issues? It's moot.)</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00389.html">Re: [tlug] issues with format of double (or IEEE754)</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00404.html">Re: [tlug] issues with format of double (or IEEE754)</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00400"><strong>Date</strong></a></li>
<li><a href="threads.html#00400"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<strong>
<a href="../index.html">Home</a> |
<a href="maillist.html">Main Index</a> |
<a href="threads.html">Thread Index</a>
</strong>
<!--X-User-Footer-End-->
 
<P>
<CENTER>
 <table border=2 width=75%><tr><td align=center>
<a href="../../index.html"> Home Page</a></td>
<td align=center><a href="../../list.html"> Mailing List </a></td>
<td align=center><a href="../../linuxinjapan.html"> Linux and Japan </a></td>
<td align=center><a href="../../members.html">TLUG Members</a></td>
<td align=center><a href="../../linuxlinks.html">Links</a></td>
</tr></TABLE>
<P>
</CENTER>
</BLOCKQUOTE>
</body>
</html>
